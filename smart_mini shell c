#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>

#define ANSI_RESET   "\033[0m"
#define ANSI_RED     "\033[1;31m"
#define ANSI_GREEN   "\033[1;32m"
#define ANSI_YELLOW  "\033[1;33m"
#define ANSI_BLUE    "\033[1;34m"
#define ANSI_CYAN    "\033[1;36m"
#define ANSI_MAGENTA "\033[1;35m"
#define ANSI_BOLD    "\033[1m"

#define TOKEN_DELIMITERS " \t\r\n\a"

// --- Parsing simple ---
char **parse_line(char *line) {
    int bufsize = 64, pos = 0;
    char **tokens = malloc(bufsize * sizeof(char*));
    char *token;

    token = strtok(line, TOKEN_DELIMITERS);
    while (token != NULL) {
        tokens[pos++] = token;
        if (pos >= bufsize) {
            bufsize += 64;
            tokens = realloc(tokens, bufsize * sizeof(char*));
        }
        token = strtok(NULL, TOKEN_DELIMITERS);
    }
    tokens[pos] = NULL;
    return tokens;
}

// --- Builtins ---
int shell_cd(char **args) {
    char *path = args[1] ? args[1] : getenv("HOME");
    if (chdir(path) != 0)
        perror(ANSI_RED "cd" ANSI_RESET);
    return 1;
}

int shell_pwd() {
    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)))
        printf(ANSI_BLUE "%s\n" ANSI_RESET, cwd);
    else
        perror(ANSI_RED "pwd" ANSI_RESET);
    return 1;
}

int shell_echo(char **args) {
    int newline = 1;
    int i = 1;

    if (args[1] && strcmp(args[1], "-n") == 0) {
        newline = 0;
        i = 2;
    }

    for (; args[i]; i++) {
        printf("%s", args[i]);
        if (args[i+1]) printf(" ");
    }
    if (newline) printf("\n");
    return 1;
}

// --- Redirections ---
void handle_redirection(char **args) {
    for (int i = 0; args[i]; i++) {
        if (strcmp(args[i], ">") == 0 && args[i+1]) {
            int fd = open(args[i+1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
            if (fd < 0) { perror("open"); exit(EXIT_FAILURE); }
            dup2(fd, STDOUT_FILENO);
            close(fd);
            args[i] = NULL;
            break;
        } 
        else if (strcmp(args[i], "<") == 0 && args[i+1]) {
            int fd = open(args[i+1], O_RDONLY);
            if (fd < 0) { perror("open"); exit(EXIT_FAILURE); }
            dup2(fd, STDIN_FILENO);
            close(fd);
            args[i] = NULL;
            break;
        }
    }
}

// --- Commande simple ---
int launch_command(char **args) {
    pid_t pid = fork();
    if (pid == 0) {
        handle_redirection(args);
        if (execvp(args[0], args) == -1) {
            perror(ANSI_RED "Erreur" ANSI_RESET);
        }
        exit(EXIT_FAILURE);
    } else if (pid < 0) {
        perror(ANSI_RED "fork" ANSI_RESET);
    } else {
        int status;
        waitpid(pid, &status, 0);
    }
    return 1;
}

// --- Multi-pipes (corrigÃ©) ---
int launch_pipes(char *line) {
    int fd_in = 0;
    char *cmd = strtok(line, "|");
    char *next = NULL;

    while (cmd) {
        next = strtok(NULL, "|");
        int pipefd[2];
        if (next) pipe(pipefd);

        pid_t pid = fork();
        if (pid == 0) {
            dup2(fd_in, 0);
            if (next) dup2(pipefd[1], 1);
            if (next) close(pipefd[0]);

            char **args = parse_line(cmd);
            handle_redirection(args);
            execvp(args[0], args);
            perror(ANSI_RED "Erreur" ANSI_RESET);
            exit(EXIT_FAILURE);
        } else {
            wait(NULL);
            if (next) {
                close(pipefd[1]);
                fd_in = pipefd[0];
            }
            cmd = next;
        }
    }
    return 1;
}

// --- Executeur global ---
int execute(char *line) {
    if (strchr(line, '|')) return launch_pipes(line);

    char **args = parse_line(line);
    if (!args[0]) { free(args); return 1; }

    if (strcmp(args[0], "cd") == 0) shell_cd(args);
    else if (strcmp(args[0], "pwd") == 0) shell_pwd();
    else if (strcmp(args[0], "echo") == 0) shell_echo(args);
    else if (strcmp(args[0], "clear") == 0) system("clear");
    else if (strcmp(args[0], "exit") == 0) {
        free(args);
        printf(ANSI_RED "Bye ðŸ‘‹\n" ANSI_RESET);
        exit(0);
    }
    else launch_command(args);

    free(args);
    return 1;
}

// --- Prompt ---
void prompt() { printf(ANSI_GREEN "smart_shell> " ANSI_RESET); }

// --- Main ---
int main() {
    char *line = NULL;
    size_t bufsize = 0;

    printf(ANSI_BOLD ANSI_MAGENTA "=== ðŸš€ Smart Mini Shell Pro++ (C) ===\n" ANSI_RESET);
    while (1) {
        prompt();
        if (getline(&line, &bufsize, stdin) == -1) {
            printf("\n" ANSI_RED "Bye ðŸ‘‹" ANSI_RESET "\n");
            break;
        }
        execute(line);
    }
    free(line);
    return 0;
}
